# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'PE2.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import (QMainWindow, QWidget, QHBoxLayout, QApplication,
                             QPushButton, QLabel, QFileDialog, QVBoxLayout,
                             QLineEdit, QComboBox)
from PyQt5.QtGui import QPixmap, QFont
from PyQt5.Qt import QSize, QImageReader
import qdarkstyle

from tkinter import filedialog
import numpy as np
from PIL import Image
from PIL import ImageQt
import os

from PyQt6.uic.uiparser import QtGui

'''
https://vimsky.com/examples/detail/python-method-qdarkstyle.load_stylesheet_pyqt5.html
https://vimsky.com/

20-1：
1、增加第二个展示窗体，增加第二个按钮
2、调整整体的界面布局，横向和纵向混合使用
3、尝试在第二个窗体展示图片,
4、在展示图片的基础上，增加已有的图片处理函数
5、处理完成后针对性保存
6、展示保存后的图片
7、加入comobox，判断列表选择
8、针对列表选择调用处理方式，并针对效果保存文件
9、针对调用方式查询是否已有文件，优先读取本地文件再考虑调用函数处理
'''


class mainwindow(QMainWindow):


    def __init__(self):
        super(mainwindow, self).__init__()

        layout = QVBoxLayout()
        w = QWidget()
        w.setLayout(layout)
        imageLabelWidth = int ((mainwindow.screen(self).size().width()-50)/2)
        imageLabelHeight = int ((mainwindow.screen(self).size().height()-150))
        mainwindow.resize(self,mainwindow.screen(self).size())#设置屏幕为设备最大画面
        # mainwindow.resizeEvent(self,self.changeWindows())#无意义
        # mainwindow.moveEvent(self,self.changeWindows())#无意义
        mainwindow.showMaximized(self)#最大化展示
        self.setWindowFlags(Qt.MSWindowsFixedSizeDialogHint)#禁止最小化

        img_layout=QHBoxLayout()
        self.setCentralWidget(w)

        self.image_label = QLabel()#展示选择图片的label
        self.image_label.setFixedSize(imageLabelWidth, imageLabelHeight)#设置label大小
        self.image_label.setAlignment(Qt.AlignCenter)#图片居中展示
        self.image_label.setStyleSheet("border: 2px solid black;")

        self.Fiximage_label = QLabel()#展示处理图片的label
        self.Fiximage_label.setFixedSize(imageLabelWidth, imageLabelHeight)#设置label大小
        self.Fiximage_label.setAlignment(Qt.AlignCenter)#图片居中展示
        self.Fiximage_label.setStyleSheet("border: 2px solid black;")

        img_layout.addWidget(self.image_label)
        img_layout.addWidget(self.Fiximage_label)
        layout.addLayout(img_layout)


        tmp_layout = QHBoxLayout()#增加布局类型，横向布局

        #增加选择图片的按钮
        CPicBtn = QPushButton("选择图片路径")
        tmp_layout.addWidget(CPicBtn)
        CPicBtn.clicked.connect(self.load_image)#按钮关联动作

        #增加处理图片的按钮：本次默认一种图片处理方法
        FPicBtn = QPushButton("处理图片")
        tmp_layout.addWidget(FPicBtn)
        FPicBtn.clicked.connect(self.show_image)  # 按钮关联动作

        #增加处理图片的按钮：本次增加两个选择项
        self.stylecomboBox = QComboBox()
        self.stylecomboBox.setObjectName("styleBox")
        tmp_layout.addWidget(self.stylecomboBox)
        self.stylecomboBox.addItem("极致色彩")
        self.stylecomboBox.addItem("漫画风格")

        #增加文本展示条
        self.result = QLineEdit()
        self.result.setPlaceholderText("车牌展示")
        self.result.setReadOnly(True)
        tmp_layout.addWidget(self.result)
        layout.addLayout(tmp_layout)

        #导入背景色样式，
        self.setStyleSheet(qdarkstyle.load_stylesheet_pyqt5())

    def show_image(self):
        '''
        https://blog.csdn.net/daimashiren/article/details/106080827?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-106080827-blog-127706764.235%5Ev38%5Epc_relevant_sort_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-106080827-blog-127706764.235%5Ev38%5Epc_relevant_sort_base3&utm_relevant_index=6
        PIL 转 Qixmap
        :return:

        https://www.codeleading.com/article/34462366185/

        '''
        imageLabelWidth = int((mainwindow.screen(self).size().width() - 50) / 2)
        imageLabelHeight = int((mainwindow.screen(self).size().height() - 150))
        fname=self.result.text()
        #获取comobox当前值
        chooseStyle=self.stylecomboBox.currentText()
        pc = PictureChange()
        pc.path = fname
        print(pc.pictureSavePath(chooseStyle))
        print()

        if fname is not None and fname != "":
            if os.path.exists(pc.pictureSavePath(chooseStyle)):
                print("本地有哦！")
            else:
                if chooseStyle=="极致色彩":
                    im=pc.Pic_HeavyColor()
                elif chooseStyle=="漫画风格":
                    im = pc.Pic_HandDraw()
                pc.pictureSavePath(chooseStyle)
                pc.CheckPath(chooseStyle)
                im.save(pc.pictureSavePath(chooseStyle))
                '''
                # img_pil=Image.open(pc.pictureSavePath("Fix"))
                # 
                # print(img_pil)
                # fname != "" 避免点击后不选择的空值导致上一次选择的图片被刷新
                # print("fname:",fname)#检查选择的名称问题
                # 
                # 还需要对图片进行重新调整大小
                # img=ImageQt.toqpixmap(img_pil)
                # self.Fiximage_label.setPixmap(pc.pictureSavePath("Fix"))
                # img=ImageQt.ImageQt(img_pil)
                # img=QPixmap.fromImage(qImage)
                # 
                # print(img)
                # img=img.read()
                # print(img)
                '''
            fix_img=QImageReader(pc.pictureSavePath(chooseStyle))
            # print(img2)
            # 针对图片的长宽问题，选择合适的最大边作为比例展示全幅画面
            if fix_img.size().height() > fix_img.size().width():
                scale = imageLabelHeight / fix_img.size().height()
                Width = int(fix_img.size().width() * scale)
                fix_img.setScaledSize(QSize(Width, imageLabelHeight))
            else:
                scale = imageLabelWidth / fix_img.size().width()
                height = int(fix_img.size().height() * scale)
                fix_img.setScaledSize(QSize(imageLabelWidth, height))

            fix_img = fix_img.read()
            # 打开设置好的图片
            pixmap = QPixmap(fix_img)
            self.Fiximage_label.setPixmap(pixmap)


    def load_image(self):
        imageLabelWidth = int((mainwindow.screen(self).size().width() - 50) / 2)
        imageLabelHeight = int((mainwindow.screen(self).size().height() - 150))
        fname, _ = QFileDialog.getOpenFileName(self, 'Open File','C://', "Image files (*.jpg *.png)")
        if fname is not None and fname != "":
            #fname != "" 避免点击后不选择的空值导致上一次选择的图片被刷新
            # print("fname:",fname)#检查选择的名称问题

            # 还需要对图片进行重新调整大小
            img = QImageReader(fname)#通过传入选择的图片路径，读取图片

            #针对图片的长宽问题，选择合适的最大边作为比例展示全幅画面
            if img.size().height()>img.size().width():
                scale = imageLabelHeight / img.size().height()
                Width = int(img.size().width() * scale)
                img.setScaledSize(QSize(Width, imageLabelHeight))
            else:
                scale = imageLabelWidth / img.size().width()
                height = int(img.size().height() * scale)
                img.setScaledSize(QSize(imageLabelWidth, height))

            img = img.read()
            # 打开设置好的图片
            pixmap = QPixmap(img)
            self.image_label.setPixmap(pixmap)
            self.result.setText(fname)
# class UI_Mainwindows(object):
#     def setupUi(self,mainwindow):
#         mainwindow.setObjectName("MM")
#         print(mainwindow)


class PictureChange:
    path=""
    savePath=""
    pathList=[]
    #这里用类的方式，给类传固定的地址，然后通过类自己的方法，返回不同地址值下的不同图片数据，

    def pictureSavePath(self,Change_text):
        # print(str_k, "拼凑保存文件夹路径【开始】", str_k)
        fileDirPath = os.path.abspath(self.path)
        # print("1"+fileDirPath)
        file_path, file_name = os.path.split(fileDirPath)
        # print("2"+file_path)
        # print("3"+file_name)

        changePath = os.path.abspath(file_path) + "\\" + str(Change_text) + "\\" + file_name
        self.savePath=changePath
        # print(changePath)
        # print(str_k, "拼凑保存文件夹路径【完成】", str_k)
        return changePath

    def CheckPath(self,Cpath):
        # 这里是对传入的文件的地址，单个处理
        fileDirPath = os.path.abspath(self.savePath)
        file_path, file_name = os.path.split(fileDirPath)
        sp = self.pictureSavePath(Cpath)
        if not os.path.exists(file_path + '\\' + Cpath):
            os.makedirs(file_path + '\\' + Cpath)
        return sp

    def Pic_HeavyColor(self):
        # im = np.array(Image.open(picture_Address).convert('L'))
        # 灰度值
        # print(str_k,"处理图片【开始】",str_k)
        im = np.array(Image.open(self.path).convert("RGB"))
        im2 = Image.fromarray(im.astype('uint8'))
        GM = 255 * (im / 255) ** 2
        im2 = Image.fromarray(GM.astype('uint8'))
        print(str_k, "处理图片【结束】", str_k)
        return im2

    def Pic_HandDraw(self):
        # print(str_k,"处理图片【开始】",str_k)
        a = np.asarray(Image.open(self.path).convert('L')).astype('float')

        depth = 20
        grad = np.gradient(a)
        grad_x, grad_y = grad
        grad_x = grad_x * depth / 100
        grad_y = grad_y * depth / 100
        A = np.sqrt(grad_x ** 2 + grad_y ** 2 + 1.)
        uni_x = grad_x / A
        uni_y = grad_y / A
        uni_z = 1. / A

        vec_el = np.pi / 2.2
        vec_az = np.pi / 4.
        dx = np.cos(vec_el) * np.cos(vec_az)
        dy = np.cos(vec_el) * np.sin(vec_az)
        dz = np.sin(vec_el)

        b = 255 * (dx * uni_x + dy * uni_y + dz * uni_z)
        b = b.clip(0.255)
        im = Image.fromarray(b.astype('uint8'))
        print(str_k, "处理图片【结束】", str_k)
        return im

if __name__ == '__main__':
    str_k = "-" * 12
    # changeDir = "处理后图片"
    # imageLabelWidth = 500
    # imageLabelHeight = 500
    app = QApplication([])
    font = QFont()
    font.setFamily("SimHei")
    font.setPointSize(14)
    app.setFont(font)
    m = mainwindow()
    m.show()
    sys.exit(app.exec())